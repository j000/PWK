<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - map controls</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<!-- <script type="text/javascript" src="http://livejs.com/live.js"></script> -->
		<script type="text/javascript" src="./live.js"></script>
		<style>
			html, body {
				margin: 0;
				width: 100vw;
				height: 100vh;
				background-color: #000;
				color: #ccc;
				overflow: hidden;
			}
			#container {
				width: 100%;
				height: 100%;
			}
		</style>
	</head>

	<body>
		<script type="module">
			// import * as THREE from 'https://unpkg.com/three/build/three.module.js';
			// import { OrbitControls } from 'https://unpkg.com/three/examples/jsm/controls/OrbitControls.js';
			import * as THREE from './three.module.js';
			import { OrbitControls } from './OrbitControls.js';

			var camera, controls, scene, renderer;

			init();
			animate();

			function init() {
				scene = new THREE.Scene();
				scene.background = new THREE.Color(0xcccccc);
				scene.fog = new THREE.FogExp2(0xcccccc, 0.002);

				renderer = new THREE.WebGLRenderer({ antialias: true });
				renderer.setPixelRatio(window.devicePixelRatio);
				renderer.setSize(window.innerWidth, window.innerHeight);
				renderer.shadowMap.enabled = true;
				document.body.appendChild(renderer.domElement);

				camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 1000);
				camera.position.set(400, 200, 0);

				// controls

				controls = new OrbitControls(camera, renderer.domElement);
				controls.screenSpacePanning = false;

				//controls.addEventListener('change', render); // call this only in static scenes (i.e., if there is no animation loop)

				controls.enableDamping = true; // an animation loop is required when either damping or auto-rotation are enabled
				controls.dampingFactor = 0.05;

				controls.minDistance = 100;
				controls.maxDistance = 500;

				controls.maxPolarAngle = (Math.PI * 0.99) / 2;

				// world

				var material = new THREE.MeshPhongMaterial({ color: 0xffffff, flatShading: true });

				var geo = new THREE.PlaneBufferGeometry(10000, 10000);
				var mesh = new THREE.Mesh(geo, material)
				mesh.position.set(0, -5, 0)
				mesh.rotation.set(Math.PI / -2, 0, 0)
				mesh.receiveShadow = true;
				scene.add(mesh)

				var geometry = new THREE.BoxBufferGeometry(1, 1, 1);
				geometry.translate(0, -0.01, 0);

				for (var i = 0; i < 500; i++) {
					var mesh = new THREE.Mesh(geometry, material);
					mesh.castShadow = true;
					mesh.receiveShadow = true;
					mesh.position.x = Math.random() * 1600 - 800;
					mesh.position.y = 0;
					mesh.position.z = Math.random() * 1600 - 800;
					mesh.scale.x = 20;
					mesh.scale.y = Math.random() * 80 + 20;
					mesh.scale.z = 20;
					mesh.updateMatrix();
					mesh.matrixAutoUpdate = false;
					scene.add(mesh);
				}

				// lights

				var light = new THREE.DirectionalLight(0xffffff, 0.9);
				light.position.set(0, 1000, 1000);
				light.position.applyAxisAngle(new THREE.Vector3(0, 1, 0), Math.PI / 6);

				light.castShadow = true;
				light.shadow.camera.near = 1;
				light.shadow.camera.far = 10000;
				light.shadow.camera.left = -1000;
				light.shadow.camera.right = 1000;
				light.shadow.camera.bottom = -1000;
				light.shadow.camera.top = 1000;

				light.shadow.mapSize.width = 4096;
				light.shadow.mapSize.height = 4096;
				scene.add(light);

				var light = new THREE.DirectionalLight(new THREE.Color("hsl(169, 60%, 40%)").getHex());
				light.position.set(0, -1, -1);
				light.position.applyAxisAngle(new THREE.Vector3(0, 1, 0), Math.PI / 6);
				scene.add(light);

				var light = new THREE.AmbientLight(new THREE.Color("hsl(294, 40%, 20%)").getHex());
				scene.add(light);

				//

				window.addEventListener('resize', onWindowResize, false);


			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize(window.innerWidth, window.innerHeight);

			}

			function animate() {
					requestAnimationFrame(animate);
					controls.update(); // only required if controls.enableDamping = true, or if controls.autoRotate = true

					renderer.render(scene, camera);
			}
		</script>
	</body>
</html>
